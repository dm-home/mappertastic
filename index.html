<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Leaflet GeoJSON Upload & Edit (Draw with Flatten)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet.draw CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #upload { padding: 0.5em; background: #f9f9f9; }
    #map { height: calc(100% - 48px); }
  </style>
</head>
<body>

  <div id="upload">
    <input type="file" id="fileInput" accept=".json,.geojson" />
    <!-- <button id="editBtn">Toggle Edit</button> -->
  </div>
  <div id="map"></div>

  <!-- Leaflet core JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet.draw JS -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <script>
    // Initialize the map
    var map = L.map('map').setView([40, -100], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Prepare FeatureGroup & draw control (edit only)
    var drawLayer = L.featureGroup().addTo(map);
    var drawControl = new L.Control.Draw({ draw: true, edit: { featureGroup: drawLayer } }).addTo(map);

    // // Toggle edit mode button
    // var editBtn = document.getElementById('editBtn');
    // editBtn.addEventListener('click', function() {
    //   var handler = drawControl._toolbars.edit._modes.edit.handler;
    //   if (!handler.enabled()) {
    //     handler.enable();
    //     editBtn.textContent = 'Finish Edit';
    //   } else {
    //     handler.disable();
    //     editBtn.textContent = 'Toggle Edit';
    //   }
    // });

    // After edit event, log updated features
    map.on('draw:edited', function(e) {
      var updated = [];
      e.layers.eachLayer(function(layer) {
        updated.push(layer.toGeoJSON());
      });
      console.log('Edited features:', updated);
    });

    // Flatten MultiPolygon into individual Polygons
    function flattenFeatures(features) {
      var out = [];
      features.forEach(function(f, idx) {
        var geom = f.geometry;
        if (!geom) return;
        if (geom.type === 'MultiPolygon') {
          geom.coordinates.forEach(function(polygon) {
            out.push({
              type: 'Feature',
              properties: f.properties || {},
              geometry: { type: 'Polygon', coordinates: polygon }
            });
          });
        } else {
          out.push(f);
        }
      });
      return out;
    }

    // Handle file upload
    document.getElementById('fileInput').addEventListener('change', function(e) {
      var file = e.target.files[0]; if (!file) return;
      var reader = new FileReader();
      reader.onload = function() {
        var data;
        try { data = JSON.parse(reader.result); }
        catch (err) { return alert('Invalid GeoJSON: ' + err.message); }

        // Wrap single Feature
        if (data.type === 'Feature') {
          data = { type: 'FeatureCollection', features: [data] };
        }
        if (data.type !== 'FeatureCollection' || !Array.isArray(data.features)) {
          return alert('GeoJSON must be a FeatureCollection or Feature');
        }

        // Flatten multipolygons
        var flat = flattenFeatures(data.features);
        console.log('Features before:', data.features.length, 'after flatten:', flat.length);
        var fc = { type: 'FeatureCollection', features: flat };

        // Clear existing layers
        drawLayer.clearLayers();

        // Add features to drawLayer
        L.geoJSON(fc, {
          onEachFeature: function(feature, layer) {
            // Only polygons and lines supported
            drawLayer.addLayer(layer);
          }
        });

        // Zoom if valid
        var bounds = drawLayer.getBounds();
        if (bounds.isValid()) {
          map.fitBounds(bounds);
        }
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>